#+TITLE: REST, mikroserwisy - Sprawozdanie
#+SUBTITLE: Dawid Macek
#+LANGUAGE: pl
#+OPTIONS: date:nil, num:nil, toc:nil
#+LATEX_HEADER: \renewcommand*{\contentsname}{Spis treści}
#+LATEX_HEADER: \usepackage[AUTO]{babel}
#+LATEX_HEADER: \usepackage[margin=0.7in]{geometry}
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>

* Zadanie 1
** Wysłanie rządań
Za pomocą CURLa pobieram to co serwuje serwer pod ~/~ i ~/helo~.

#+begin_src bash
$ curl -sX GET http://localhost:3000/
<h1>HTTP Server</h1><p>Go to /hello subpage!</p>

$ curl -sX GET http://localhost:3000/hello
<p>Anonymous message: Oh, Hi Mark!</p>
#+end_src

Po stronie serwera wyświetlane zostają opdowiednie komunikaty:
#+begin_src
Handling GET /
Handling GET /hello
#+end_src

** Modyfikacja kodu raportującego

Funkcja ~printReqSummary~ przed modyfikacją i po dodaniu timestampu.
#+begin_src js
// function printReqSummary(request) {
//   // Display handled HTTP method and link (path + queries)
//   console.log(`Handling ${request.method} ${request.originalUrl}`);
// }

function printReqSummary(request) {
  // Display handled HTTP method and link (path + queries)
  console.log(`[${Date.now()}] ${request.method} ${request.originalUrl}`);
}
#+end_src

Po zmianie wiadomości wyglądają następująco:
#+begin_src 
[1578782272022] GET /
[1578782273009] GET /hello
#+end_src

** Endpoint ~/time~
   Nowy endpoint powinien zwracać obecny timestamp.

   #+begin_src js
// GET /time -- Show current timestamp
app.get("/time", function(request, response) {
  printReqSummary(request);
  response.send(`<p>${Date.now()}</p>`);
});   
   #+end_src


** Test ~/time~
   Wysłanie zapytania:
   #+begin_src bash
   $ curl -sX GET http://localhost:3000/time
   <p>1578782499294</p>o 
   #+end_src

   Log serwera:
   #+begin_src
   [1578782499294] GET /time   
   #+end_src

* Zadanie 2
** Testowanie endpointów
*** Dla ~/~
    Wyświetlona zostaje lista obsługiowanych endpointów wraz z informacją o parametrach i kluczach query-stringów.
    #+begin_src bash 
$ curl -sX GET http://localhost:3000
<h1>URL Parameters (and Queries)</h1><ul>
      <li>Show normal message (GET /hello/segment1)</li>
      <li>Show special message (GET /hello/segment1/segment2?age=NUMBER&height=NUMBER)</li>
          <li>  where segment1, segment2 - any valid URL part</li>
          </ul>    
    #+end_src

*** Dla ~/hello/:name~
    To co podamy w miejscu ~:name~ zostanie użyte do budowania odpowiedzi.
    Jeżeli nie podamy nic, to Express uzna, że pytamy o ścieżkę ~/hello/~, która nie jest zdefiniowana.
    #+begin_src bash
$ curl -sX GET http://localhost:3000/hello/Arthur
<p>Normal message for: Dawid</p>    

$ curl -sX GET http://localhost:3000/hello/John
<p>Normal message for: Andrzej</p>

$ curl -sX GET http://localhost:3000/hello/
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Error</title>
</head>
<body>
<pre>Cannot GET /hello/</pre>
</body>
</html>
    #+end_src

*** Dla ~/hello/:name/:surname?age=_&height=_~
    Poniższe wyniki pokazują, że query-stringi są opcjonalne.
    W wypadku braku odpowiedniego klucza, pole w odpowiedzi ma wartość ~undefined~.
    Brak walidacji, ponieważ w poach numereycznych można wpisać dowolne ciągi znaków.

    #+begin_src 
    $ curl -sX GET http://localhost:3000/hello/John/Doe
    <p>Special message for: John Doe
      (age: undefined years, height: undefined cm)</p>    

    $ curl -sX GET http://localhost:3000/hello/John/Doe?age=22
    <p>Special message for: John Doe
      (age: 22 years, height: undefined cm)</p>

    $ curl -sX GET http://localhost:3000/hello/John/Doe?height=22
    <p>Special message for: John Doe
      (age: undefined years, height: 22 cm)</p>

    $ curl -sX GET http://localhost:3000/hello/John/Doe?age=22\&height=22
    <p>Special message for: John Doe
      (age: 22 years, height: 22 cm)</p>

    $ curl -sX GET http://localhost:3000/hello/John/Doe?age=22\&height=kopytko
    <p>Special message for: John Doe
      (age: 22 years, height: kopytko cm)</p>
    #+end_src
** Endpoint zwracający losowe parametry
   Korzystam z podanej funkcji, z tym że zdefiniowałem ją jako lambdę.
   #+begin_src js
// GET /rand/:a/:b/:c -- Return one of :a, :b, :c
app.get("/rand/:a/:b/:c", function(req, response) {
    printReqSummary(req);

    let randint = (min, max) => { return Math.floor(Math.random() * (max - min + 1)) + min; },
        rand = [req.params.a, req.params.b, req.params.c][randint(0, 2)];
    response.send(`<p>${rand}</p>`);
});
   #+end_src

   Po wysłaniu wielu zapytań pod nowo-zdefiniowany endpoint widać, że wyniki są w miarę losowe:
   #+begin_src bash
$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>schabowe</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>kotlety</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>lubie</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>schabowe</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>kotlety</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>schabowe</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>schabowe</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>lubie</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>kotlety</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>kotlety</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>lubie</p>

$ curl -sX GET http://localhost:3000/rand/lubie/kotlety/schabowe
<p>schabowe</p>   
   #+end_src
