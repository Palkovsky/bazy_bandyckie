#+TITLE: Neo4j - Sprawozdanie
#+SUBTITLE: Dawid Macek
#+LANGUAGE: pl
#+OPTIONS: date:nil, num:nil, toc:nil
#+LATEX_HEADER: \renewcommand*{\contentsname}{Spis treści}
#+LATEX_HEADER: \usepackage[AUTO]{babel}
#+LATEX_HEADER: \usepackage[margin=0.7in]{geometry}
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>

* Zadanie 1
  Bazę odpalam w kontenerze.
  Do zarządzania nim używam poniższego skryptu:

  #+begin_src bash
  #!/bin/bash
  CNAME="neo4j_node"
  case "$1" in
      tty)
          docker exec -it $CNAME /bin/bash
          ;;
      kill)
          docker kill $CNAME
          ;;
      *)
          docker pull neo4j
          docker run \
                 --name $CNAME --rm \
                 -p 7687:7687 -p 7474:7474 \
                 -v /$(pwd)/data:/data \
                 --env=NEO4J_AUTH=none \
                 --env=NEO4J_dbms_allow__upgrade=true \
                 neo4j
          ;;
  esac
  #+end_src

  Opcja ~tty~ nie działa na Windowsie z emulatorem  ~Git Bash~, ale w zadaniach nie ma potrzeby majstrowania przy kontenerach.

* Zadanie 2
  Po prostu przekleiłem trzy kolejne zapytania.

** Filmy
  #+begin_src 
LOAD CSV WITH HEADERS FROM 
  'https://neo4j.com/docs/cypher-manual/3.5/csv/query-tuning/movies.csv'  AS line
MERGE (m:Movie { title: line.title })
ON CREATE SET m.released = toInteger(line.released), m.tagline = line.tagline
  #+end_src

** Aktorzy
  #+begin_src 
LOAD CSV WITH HEADERS FROM 
  'https://neo4j.com/docs/cypher-manual/3.5/csv/query-tuning/actors.csv' AS line
MATCH (m:Movie { title: line.title })
MERGE (p:Person { name: line.name })
ON CREATE SET p.born = toInteger(line.born)
MERGE (p)-[:ACTED_IN { roles:split(line.roles, ';')}]->(m)
  #+end_src

** Reżyserzy
  #+begin_src 
LOAD CSV WITH HEADERS FROM 
  'https://neo4j.com/docs/cypher-manual/3.5/csv/query-tuning/directors.csv' AS line
MATCH (m:Movie { title: line.title })
MERGE (p:Person { name: line.name })
ON CREATE SET p.born = toInteger(line.born)
MERGE (p)-[:DIRECTED]->(m)
  #+end_src
  
* Zadanie 3

Zadania z językiem programowania rozwiązuję w [[https://www.rust-lang.org/][Ruście]] używając biblioteki [[https://docs.rs/rusted_cypher/1.1.0/rusted_cypher/][rusted​_cypher]].

** Framework do zoadań
   #+begin_src rust
    use rusted_cypher::GraphClient;
    use rusted_cypher::error::GraphError;

    type Res<T> = Result<T, GraphError>;

    const CONN_URL: &'static str = "http://neo4j:neo4j@localhost:7474/db/data";

    fn main() -> Res<()> {
        let mut graph = GraphClient::connect(CONN_URL)?;

        zadanie(&mut graph)?;

        Ok(())
    }

    fn zadanie(graph: &mut GraphClient) -> Res<()> {
        // miejsce na kod
        Ok(())
    }
   #+end_src

** Rozwiązanie
   Zaimplementować funkcję (wystarczy wykonać jedno zapytanie typu MATCH WHERE i wyświetlić
wynik).    

   #+begin_src rust
fn zadanie3(graph: &mut GraphClient) -> Res<()> {
   let result = graph.exec(
        "MATCH (n:Movie) WHERE n.released > 2000 RETURN n.title, n.tagline, n.released LIMIT 25")?;

    for row in result.rows() {
        let (title, tagline, release) =
            (row.get::<String>("n.title")?,
             row.get::<String>("n.tagline")?,
             row.get::<usize>("n.released")?);

        println!("{} | {}\r\n{}\r\n--------", title, release, tagline);
    }

    Ok(())
}
   #+end_src

** Wynik

   [[./imgs/1.png]]

* Zadanie 4
** Kod
   #+begin_src rust
fn zadanie4(graph: &mut GraphClient) -> Res<()> {
    let mk_movie = |q: &mut CypherQuery, title: &str, tagline: &str, released: usize| -> Res<()> {
        let statement = Statement::new(
            "CREATE (n: Movie { title: {title}, tagline: {tagline}, released: {released} })"
        )
            .with_param("title", title)?
            .with_param("tagline", tagline)?
            .with_param("released", released)?;

        q.add_statement(statement);

        Ok(())
    };

    let mk_actor = |q: &mut CypherQuery, name: &str, born: usize| -> Res<()> {
        let statement = Statement::new(
            "CREATE (n: Person { name: {name}, born: {born} })"
        )
            .with_param("name", name)?
            .with_param("born", born)?;

        q.add_statement(statement);

        Ok(())
    };

    let mk_acted_in = |q: &mut CypherQuery, mov_title: &str, act_name: &str| -> Res<()> {
        // indoc to makro, które usuwa wcięcia przy wielolinioych stringach
        let statement = Statement::new(indoc!(
            "MATCH (n: Movie { title: {title} }), (m: Person { name: {name} })
             CREATE (m)-[:ACTED_IN]->(n)"
        ))
            .with_param("title", mov_title)?
            .with_param("name", act_name)?;

        q.add_statement(statement);

        Ok(())
    };

    let mut query = graph.query();
    mk_movie(&mut query, "Smoleńsk", "Prawda zwycięży", 2016)?;

    mk_actor(&mut query, "Lech Łotocki", 1947)?;
    mk_acted_in(&mut query, "Smoleńsk", "Lech Łotocki")?;

    mk_actor(&mut query, "Aldona Struzik", 1964)?;
    mk_acted_in(&mut query, "Smoleńsk", "Aldona Struzik")?;

    mk_actor(&mut query, "Beata Fido", 1967)?;
    mk_acted_in(&mut query, "Smoleńsk", "Beata Fido")?;

    query.send().map(|_| ())
}   
   #+end_src
** Wynik
   [[./imgs/2.png]]

* Zadanie 5
  Dodaję atrybuty ~birthplace~ i ~salary~.

** Kod
   #+begin_src rust
fn zadanie5(graph: &mut GraphClient) -> Res<()> {
    let mk_props = |act_name: &str, birthplace: &str, salary: usize| -> Res<Statement> {
        Statement::new(indoc!(
            "MATCH (n: Person { name: {name} })
            SET n.birthplace = {birthplace}, n.salary = {salary}"
        ))
            .with_param("name", act_name)?
            .with_param("birthplace", birthplace)?
            .with_param("salary", salary)
            .or(Err(GraphError::from("Invalid statement".to_string())))
    };

    let q = mk_props("Lech Łotocki", "Kraków", 1000000)?;
    graph.exec(q)?;

    Ok(())
}   
   #+end_src
** Wynik
   [[./imgs/3.png]]


* Zadanie 6
  Dla filmów wydanych po roku dwutysięcznym do tytułu dopiszemy rok wydania.
  Na przykład:
  #+begin_src 
  Smoleńsk => Smoleńsk 2016
  #+end_src

** Kod
   #+begin_src rust
fn zadanie6(graph: &mut GraphClient) -> Res<()> {
    graph.exec(
        "MATCH (n: Movie) WHERE n.released > 2000
        SET n.title = n.title + ' ' + n.released
        RETURN n"
    )?;
    Ok(())
}
   #+end_src

** Wynik
   [[./imgs/4.png]]

* Zadanie 7
** Aktorzy którzy grali w conajmniej dwóch filmach
*** Kod
   #+begin_src rust
fn zadanie7a(graph: &mut GraphClient) -> Res<()> {
    let result = graph.exec(
        "MATCH (n:Person) -[:ACTED_IN]-> (m:Movie)
         WITH n, LENGTH(COLLECT(m)) as cnt
         WHERE cnt >= 2
         RETURN n.name, cnt"
    )?;

    for row in result.rows() {
        let (name, cnt) =
            (row.get::<String>("n.name")?,
             row.get::<usize>("cnt")?);

        println!("{} | {} \r\n--------", name, cnt);
    }

    Ok(())
}   
   #+end_src

*** Wynik - częściowo ucięte
    [[./imgs/5.png]]

** Średnia wystąpień w filmach dla grupy aktorów, którzy wystąpili w conajmniej 3 filmach
*** Kod
    #+begin_src rust
fn zadanie7b(graph: &mut GraphClient) -> Res<()> {
    let result = graph.exec(
        "MATCH (n:Person) -[:ACTED_IN]-> (m:Movie)
         WITH n, LENGTH(COLLECT(m)) as cnt
         WHERE cnt >= 3
         RETURN AVG(cnt) as avg"
    )?;

    for row in result.rows() {
        let avg = row.get::<f64>("avg")?;
        println!("{}", avg);
    }

    Ok(())
}    
    #+end_src

*** Wynik dzialania
   [[./imgs/6.png]]

* Zadanie 9
  Wszystkim węzłom na najkrótszej ścieżce pomiędzy Kevinem Baconem a Keanu Reevsem ustawiam atrybut ~mark=true~.

** Kod
   #+begin_src rust
fn zadanie9(graph: &mut GraphClient) -> Res<()> {
    graph.exec(
     "MATCH p=shortestPath((a:Person {name: 'Kevin Bacon'})-[*]-(b:Person {name: 'Keanu Reeves'}))
      WITH NODES(p) AS nds
      UNWIND nds AS ns
      SET ns.mark=true
      RETURN ns"
    )?;
    Ok(())
}   
   #+end_src
** Wynik
   [[./imgs/7.png]]

* Zadanie 10

  Matchujemy pierwszy i ostatni węzeł na ścieżce pomiędzy Kevin Baconem i Keanu Reevsem.
  Pozostałe dwa matchujemy za pomocą ~-[2*]-~.

** Kod
   #+begin_src rust
fn zadanie9(graph: &mut GraphClient) -> Res<()> {
    let result = graph.exec(
        "MATCH p=
         (a:Person {name: 'Kevin Bacon'})-
         [r1]-(n)-[*2]-(m)-[r3]-
         (b:Person {name: 'Keanu Reeves'})
         RETURN n,  m")?;

    // API nie ułatwia wyłuskiwania danych z takich obiektów, więc
    // użyłem debug printa.
    result.data
        .iter()
        .next()
        .map(|row| println!("{:?}", row));

    Ok(())
}   
   #+end_src

** Wynik
   Można porównać z wynikiem poprzedniego zapytania. 
   Węzły na drugich miejscach są to filmy ~A Few Good Men~ i ~Something's Gotta Give~.
   Tak się złożyło, że najkrótsza ścieżka jest jedyna i ma długość 4.
   [[./imgs/8.png]]

* Zadanie 11
  
Będziemy zajmować się poniższym zapytaniem:

#+begin_src 
 MATCH (n: Person {name: 'Kevin Bacon'}) RETURN n;
#+end_src

** Bez indeksu
[[./imgs/11a.png]]
[[./imgs/11b.png]]

** Założenie indeksu
   #+begin_src 
   CREATE INDEX ON :Person(name);
   #+end_src

** Z indeksem
[[./imgs/11c.png]]
[[./imgs/11d.png]]


** Wnioski
   Bez indeksu egzekutor zapytań musi przeszukać wszystkie węzły z labelem ~Person~ (jest ich 128).
   Z indeksem egzekutor wie gdzie jest poszukiwany węzeł i od razu do niego przechodzi.

   Czas bez indeksu: ~10ms~.
   Czas z indeksem: ~1ms~.

* Zadanie 12
** Zapytanie 1

   Akutualizacja pól na ścieże pomiędzy dwoma węzłami.
   Optymalizacja będzie polegała na dodaniu indeksu na polu ~name~.

   #+begin_src 
   MATCH p=shortestPath((a:Person {name: 'Kevin Bacon'})-[*]-(b:Person {name: 'Keanu Reeves'}))
   WITH NODES(p) AS nds
   UNWIND nds AS ns
   SET ns.mark=true
   RETURN p
   #+end_src

*** Bez indeksu na 'name'
    [[./imgs/12a.png]]

*** Z indeksem na 'name'
    [[./imgs/12b.png]]

*** Wnioski
    Dodanie indeksu poprawiło czas wykonania z 10ms do 2ms.

** Zapytanie 2

   Zapytanie, które aktualizuje tytuły filmów wydanych po roku dwutysięcznym.
   Optymalizacja będzie polegała na stworzeniu indeksu na polu ~released~.

   #+begin_src 
   MATCH (n: Movie) WHERE n.released > 2000
   SET n.title = n.title + ' ' + n.released
   RETURN n
   #+end_src

*** Bez indeksu
    [[./imgs/12c.png]]

*** Z indeksem
    [[./imgs/12d.png]]

*** Wnioski
    Dla zapytań przedziałowych indeksy nie dają aż tak dobrych rezultatów jak dla zapytań z równością, bo egzekutor wciąż musi wyszukiwać przez połowienie.
    Niemniej jednak, przyśpieszenie cały czas występuje.

* Zadnie 13
