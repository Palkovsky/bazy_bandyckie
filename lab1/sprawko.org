#+TITLE: Oracle PL/SQL - Sprawozdanie
#+LANGUAGE: pl
#+OPTIONS: date:nil
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
#+LATEX_HEADER: \renewcommand*{\contentsname}{Spis treści}

* Schemat bazy
  Kod użyty do wygenerowania schematu bazy danych został skopiowany z dokumentu z zadaniami.
   #+begin_src sql
   CREATE TABLE OSOBY (
   ID_OSOBY INT GENERATED ALWAYS AS IDENTITY NOT NULL,
   IMIE VARCHAR2(50),
   NAZWISKO VARCHAR2(50),
   PESEL VARCHAR2(11),
   KONTAKT VARCHAR2(100),
   CONSTRAINT OSOBY_PK PRIMARY KEY (ID_OSOBY) ENABLE
   );

   CREATE TABLE WYCIECZKI (
   ID_WYCIECZKI INT GENERATED ALWAYS AS IDENTITY NOT NULL,
   NAZWA VARCHAR2(100),
   KRAJ VARCHAR2(50),
   DATA DATE,
   OPIS VARCHAR2(200),
   LICZBA_MIEJSC INT,
   CONSTRAINT WYCIECZKI_PK PRIMARY KEY (ID_WYCIECZKI) ENABLE
   );

   CREATE TABLE REZERWACJE (
   NR_REZERWACJI INT GENERATED ALWAYS AS IDENTITY NOT NULL,
   ID_WYCIECZKI INT,
   ID_OSOBY INT,
   STATUS CHAR(1),
   CONSTRAINT REZERWACJE_PK PRIMARY KEY (NR_REZERWACJI) ENABLE
   );

   ALTER TABLE REZERWACJE 
   ADD CONSTRAINT REZERWACJE_FK1 
   FOREIGN KEY (ID_OSOBY)
   REFERENCES OSOBY (ID_OSOBY)
   ENABLE;
   
   ALTER TABLE REZERWACJE
   ADD CONSTRAINT REZERWACJE_FK2 FOREIGN KEY (ID_WYCIECZKI)
   REFERENCES WYCIECZKI (ID_WYCIECZKI)
   ENABLE;
   
   ALTER TABLE REZERWACJE
   ADD CONSTRAINT REZERWACJE_CHK1 CHECK (status IN ('N','P','Z','A'))
   ENABLE;
   #+end_src
   
* Przykładowe dane
   Baza ma zawierać:
   - 4 wycieczki
   - 10 osób
   - 10 rezerwacji

   #+begin_src sql
/* OSOBY */
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Adam', 'Kowalski', '87654321', 'tel: 6623');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Jan', 'Nowak', '12345678', 'tel: 2312, dzwonić po 18.00');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Wacław', 'Frydrych', '489712678', 'frydrych@agh.edu.pl');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Mariusz', 'Meszka', '237894156', 'meszka@agh.edu.pl');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Marek', 'Gajęcki', '731648726', 'mgajecki@agh.edu.pl');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Jarosław', 'Koźlak', '157894635', 'kozlak@agh.edu.pl');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Piotr', 'Faliszewski', '712347596', 'faliszw@agh.edu.pl');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Robert', 'Marcjan', '712456389', 'marcjan@agh.edu.pl');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Robert', 'Kubica', '487123549', 'robert@orlen.pl');
INSERT INTO osoby (imie, nazwisko, pesel, kontakt)
    VALUES('Rafał', 'Juraszek', '45978123', 'rafal@gmail.com');

/* WYCIECZKI */
INSERT INTO wycieczki (nazwa, kraj, data, opis, liczba_miejsc) VALUES (
  'Wycieczka do Paryza',
  'Francja', 
  TO_DATE('2019-01-01','YYYY-MM-DD'),
  'Ciekawa wycieczka ...',
  3
);
INSERT INTO wycieczki (nazwa, kraj, data, opis, liczba_miejsc) VALUES (
  'Piękny Kraków',
  'Polska',
  TO_DATE('2020-02-03','YYYY-MM-DD'),
  'Najciekawa wycieczka ...',
  2
);
INSERT INTO wycieczki (nazwa, kraj, data, opis, liczba_miejsc) VALUES (
  'Wieliczka',
  'Polska', 
  TO_DATE('2020-03-03','YYYY-MM-DD'),
  'Zadziwiająca kopalnia ...',
  2
);
INSERT INTO wycieczki (nazwa, kraj, data, opis, liczba_miejsc) VALUES (
  'Wycieczka do Londynu',
  'Anglia',
  TO_DATE('2020-04-03','YYYY-MM-DD'),
  'Lux wycieczka, Big Ben i takie tam.', 
  4
);

/* REZERWACJE */
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (1,1,'N');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (2,2,'P');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (2,4,'A');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (4,9,'Z');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (4,3,'P');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (4,8,'P');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (3,5,'N');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (3,1,'Z');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (4,7,'N');
INSERT INTO rezerwacje(id_wycieczki, id_osoby, status) VALUES (1,3,'N');
   #+end_src

* Widoki
  Tworzenie widoków. Należy przygotować kilka widoków ułatwiających dostęp do danych.

** wycieczki​_osoby
   Widok łączy informacje o wycieczkach z uczestnikami na podstawie rezerwacji.
   #+begin_src sql
   CREATE OR REPLACE VIEW wycieczki_osoby
   AS
    SELECT
        w.ID_WYCIECZKI,
        w.NAZWA,
        w.KRAJ,
        w.DATA,
        o.IMIE,
        o.NAZWISKO,
        r.STATUS
    FROM
         WYCIECZKI w
    JOIN
        REZERWACJE r ON w.ID_WYCIECZKI = r.ID_WYCIECZKI
    JOIN
        OSOBY o ON r.ID_OSOBY = o.ID_OSOBY;
   #+end_src

** wycieczki​_osoby​_potwierdzone
   Widok zwraca informacje o potwierdzonych uczestnikach, czyli tych którzy potwierdzili i zapłacili.

   #+begin_src sql
CREATE OR REPLACE VIEW wycieczki_osoby_potwierdzone
 AS
    SELECT
        *
    FROM
         wycieczki_osoby
    WHERE
         STATUS = 'Z';
   #+end_src

** wycieczki​_przyszle
   Informacje o wycieczkach, które jeszcze się nie odbyły oraz ich uczestnikach.
   #+begin_src sql
CREATE OR REPLACE VIEW wycieczki_przyszle
 AS
    SELECT
        *
    FROM
      wycieczki_osoby
    WHERE
       DATA > CURRENT_DATE;
   #+end_src

** wycieczki​_miejsca
   Zwraca informacje o zajętości miejsc poszczególnych wycieczek. Jeśli jakaś rezerwacja została anulowana, to uznajemy że miejsce jest wolne.
   #+begin_src sql
CREATE OR REPLACE VIEW wycieczki_miejsca
 AS
    SELECT
        w.ID_WYCIECZKI,
        w.NAZWA,
        w.KRAJ,
        w.DATA,
        w.LICZBA_MIEJSC,
        w.LICZBA_MIEJSC - COUNT(r.ID_WYCIECZKI) as LICZBA_WOLNYCH_MIEJSC
 FROM
      WYCIECZKI w
 INNER JOIN
      REZERWACJE r ON w.ID_WYCIECZKI = r.ID_WYCIECZKI
 WHERE
       r.STATUS != 'A'
 GROUP BY
          w.ID_WYCIECZKI, w.NAZWA, w.KRAJ, w.DATA, w.LICZBA_MIEJSC;   
   #+end_src

** dostepne​_wycieczki
   Zwraca informacje o wycieczkach, które jeszcze się nie odbyły i mają wolne miejsca.
   #+begin_src sql
CREATE OR REPLACE VIEW dostepne_wycieczki
 AS
    SELECT
           *
    FROM
        wycieczki_miejsca
    WHERE
        LICZBA_WOLNYCH_MIEJSC > 0 AND DATA > CURRENT_DATE;   
   #+end_src

** rezerwacje​_do​_anulowania 
   Lista niepotwierdzonych rezerwacji które powinne zostać anulowane, rezerwacje przygotowywane są do anulowania na tydzień przed wyjazdem.
   #+begin_src sql
CREATE OR REPLACE VIEW rezerwacje_do_anulowania
  AS
    SELECT DISTINCT
        r.NR_REZERWACJI,
        r.ID_WYCIECZKI,
        r.ID_OSOBY,
        w.NAZWA,
        w.DATA,
        o.IMIE,
        o.NAZWISKO,
        o.KONTAKT
    FROM
        REZERWACJE r
    INNER JOIN
        OSOBY O on r.ID_OSOBY = O.ID_OSOBY
    INNER JOIN
        WYCIECZKI W on r.ID_WYCIECZKI = W.ID_WYCIECZKI
    WHERE
        w.DATA - CURRENT_DATE <= 7 AND r.STATUS != 'Z';
   #+end_src

* Procedury pobierające dane
  Procedury, które coś zwracają bez modyfikowania danych nazywamy ~funkcjami~. 
  Ich zaletą jest możliwość używania ich w zapytaniach ~SQL~, w porównaniu do typowych procedur, które można używać tylko w ~PL/SQL~.
  
  Ponieważ funkcje mogą zwracać tylko jedną wartość trzeba tworzyć specjalne typy tabel, które będą kolekcją zwracanych rekordów.
  Pozwala to osiągnąć efekt podobny do tego co oferują widoki, ale wywoływanych jako funkcje z obsługą błędów.

** uczestnicy​_wycieczki(id​_wycieczki)
   Procedura zwraca zestaw danych podobnych do tego z widoku ~wycieczki_osoby~.

   #+begin_src sql
/* Pojedynczy rekord */
CREATE OR REPLACE TYPE UCZESTNICY_WYCIECZKI_RECORD AS OBJECT (
  ID_WYCIECZKI  NUMBER,
  NAZWA         VARCHAR2(100),
  KRAJ          VARCHAR2(50),
  "DATA"        DATE,
  IMIE          VARCHAR2(50),
  NAZWISKO      VARCHAR(50),
  STATUS        CHAR(1)
);

/* Kolekcja rekordów */
CREATE OR REPLACE TYPE UCZESTNICY_WYCIECZKI_TABLE IS TABLE OF UCZESTNICY_WYCIECZKI_RECORD;

CREATE OR REPLACE
FUNCTION uczestnicy_wycieczki(id INT)
    RETURN UCZESTNICY_WYCIECZKI_TABLE AS result UCZESTNICY_WYCIECZKI_TABLE;
    record_count INT;
    BEGIN
        /* Upewnij się, że wycieczka istnieje */
        SELECT COUNT(*) INTO record_count FROM WYCIECZKI WHERE ID_WYCIECZKI = id;
        IF (record_count != 1) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Record doest not exist.');
        END IF;

        /* Zbierz wynik do utworznej tabeli */
        SELECT UCZESTNICY_WYCIECZKI_RECORD(
            w.ID_WYCIECZKI, w.NAZWA, w.KRAJ, w.DATA, o.IMIE, o.NAZWISKO, r.STATUS)
        BULK COLLECT INTO
            result
        FROM
            WYCIECZKI w
        JOIN
            REZERWACJE r ON w.ID_WYCIECZKI = r.ID_WYCIECZKI
        JOIN
            OSOBY o ON r.ID_OSOBY = o.ID_OSOBY
        WHERE
            w.ID_WYCIECZKI = id AND r.STATUS != 'A';

        /* Zwróć tabelę */
        RETURN result;
    END uczestnicy_wycieczki;
   #+end_src

   Wyniki powyższej funkcji można teraz wykorzystywać w następujący sposób:
   #+begin_src sql
   SELECT * FROM TABLE(uczestnicy_wycieczki(1));
   #+end_src

** rezerwacje​_osoby(id​_osoby) 
   Procedura zwraca podobny zestaw danych do tego z widoku ~wycieczki_osoby~.
   #+begin_src sql
CREATE OR REPLACE TYPE REZERWACJE_OSOBY_RECORD AS OBJECT (
  ID_WYCIECZKI  NUMBER,
  NAZWA         VARCHAR2(100),
  KRAJ          VARCHAR2(50),
  "DATA"        DATE,
  IMIE          VARCHAR2(50),
  NAZWISKO      VARCHAR(50),
  STATUS        CHAR(1)
);
CREATE OR REPLACE TYPE REZERWACJE_OSOBY_TABLE IS TABLE OF REZERWACJE_OSOBY_RECORD;

CREATE OR REPLACE
FUNCTION rezerwacje_osoby(id INT)
    RETURN REZERWACJE_OSOBY_TABLE AS result REZERWACJE_OSOBY_TABLE;
    record_count INT;
    BEGIN
        /* Upewnij się, że osoba istnieje */
        SELECT COUNT(*) INTO record_count FROM OSOBY WHERE ID_OSOBY = id;
        IF (record_count != 1) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Record doest not exist.');
        END IF;

        /* Zbierz wynik do utworznej tabeli */
        SELECT REZERWACJE_OSOBY_RECORD(
            w.ID_WYCIECZKI, w.NAZWA, w.KRAJ, w.DATA, o.IMIE, o.NAZWISKO, r.STATUS)
        BULK COLLECT INTO
            result
        FROM
            WYCIECZKI w
        JOIN
            REZERWACJE r ON w.ID_WYCIECZKI = r.ID_WYCIECZKI
        JOIN
            OSOBY o ON r.ID_OSOBY = o.ID_OSOBY
        WHERE
            o.ID_OSOBY = id AND r.STATUS != 'A';

        /* Zwróć tabelę */
        RETURN result;
    END rezerwacje_osoby;
   #+end_src

** przyszle​_rezerwacje​_osoby(id​_osoby) 
   Procedura zwracająca informacje o rezerwacjach danej osoby na wycieczki odbywające się w przyszłości.
   #+begin_src sql
CREATE OR REPLACE TYPE PRZYSZLE_REZERWACJE_OSOBY_RECORD AS OBJECT (
  ID_WYCIECZKI  NUMBER,
  NAZWA         VARCHAR2(100),
  KRAJ          VARCHAR2(50),
  "DATA"        DATE,
  IMIE          VARCHAR2(50),
  NAZWISKO      VARCHAR(50),
  STATUS        CHAR(1)
);
CREATE OR REPLACE TYPE PRZYSZLE_REZERWACJE_OSOBY_TABLE IS TABLE OF PRZYSZLE_REZERWACJE_OSOBY_RECORD;

CREATE OR REPLACE
FUNCTION przyszle_rezerwacje_osoby(id INT)
    RETURN PRZYSZLE_REZERWACJE_OSOBY_TABLE AS result PRZYSZLE_REZERWACJE_OSOBY_TABLE;
    record_count INT;
    BEGIN
        /* Upewnij się, że osoba istnieje */
        SELECT COUNT(*) INTO record_count FROM OSOBY WHERE ID_OSOBY = id;
        IF (record_count != 1) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Record doest not exist.');
        END IF;

        /* Zbierz wynik do utworznej tabeli */
        SELECT PRZYSZLE_REZERWACJE_OSOBY_RECORD(
            w.ID_WYCIECZKI, w.NAZWA, w.KRAJ, w.DATA, o.IMIE, o.NAZWISKO, r.STATUS)
        BULK COLLECT INTO
            result
        FROM
            WYCIECZKI w
        JOIN
            REZERWACJE r ON w.ID_WYCIECZKI = r.ID_WYCIECZKI
        JOIN
            OSOBY o ON r.ID_OSOBY = o.ID_OSOBY
        WHERE
            o.ID_OSOBY = id AND r.STATUS != 'A' AND w.DATA > CURRENT_DATE;

        /* Zwróć tabelę */
        RETURN result;
    END przyszle_rezerwacje_osoby;
   #+end_src

** dostepne​_wycieczki(kraj, od, do)
   Funkcja wykorzystuje wcześniej stworzony widok ~dostepne_wycieczki~, który zapewnia że są wolne miejsca oraz że wycieczka jeszcze się nie odbyła.
   W procedurze sprawdzamy czy zakres dat jest poprawny.

   #+begin_src sql
CREATE OR REPLACE TYPE DOSTEPNE_WYCIECZKI_RECORD AS OBJECT (
  ID_WYCIECZKI  NUMBER,
  NAZWA         VARCHAR2(100),
  KRAJ          VARCHAR2(50),
  "DATA"        DATE,
  WOLNE_MIEJSCA NUMBER
);
CREATE OR REPLACE TYPE DOSTEPNE_WYCIECZKI_TABLE IS TABLE OF DOSTEPNE_WYCIECZKI_RECORD;

CREATE OR REPLACE
    FUNCTION dostepne_wycieczki_func(kraj WYCIECZKI.KRAJ%TYPE, data_od DATE, data_do DATE)
    RETURN DOSTEPNE_WYCIECZKI_TABLE AS result DOSTEPNE_WYCIECZKI_TABLE;
    BEGIN
        /* Upewnij się, że przedział dat jest okej */
        IF data_do < data_od THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid date range.');
        END IF;

        /* Zbierz wynik do utworznej tabeli.
           Używamy widoku dostępne wycieczki, który bierze pod uwagę ilość miejsc. */
        SELECT DOSTEPNE_WYCIECZKI_RECORD(
            w.ID_WYCIECZKI, w.NAZWA, w.KRAJ, w.DATA, w.LICZBA_WOLNYCH_MIEJSC)
        BULK COLLECT INTO
            result
        FROM
            DOSTEPNE_WYCIECZKI w
        WHERE
             w.KRAJ = dostepne_wycieczki_func.kraj AND
             w.DATA >= data_od AND
             w.DATA <= data_do;

        /* Zwróć tabelę */
        RETURN result;
    END dostepne_wycieczki_func;   
   #+end_src
  
* Procedury modyfikujące dane

